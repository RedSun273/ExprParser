# Как устроена эта задача?
Она разделена на три подзадачи, каждая последующая включает в себя предыдущие. Поэтому code-review будем проводить самой полной подзадачи (сдашь первую и вторую — проверим вторую и засчитаем обе; сдашь только третью — проверим ее и засчитаем сразу все).

# Формулировка   
Нужно написать парсер математических выражений, содержащих случайные величины.

Нужно скачать проект RandomVariable и реализовать RandomVariableStatisticCalculator. Его единственный метод принимает строку, описывающую случайную величину, и набор видов статистик, которые нужно вычислить.

Строка представляет собой корректное математическое выражение, состоящие из унарных (+-) и бинарных (+-*/) операторов, скобок и операндов — чисел и случайных величин. Числа могут записываться как в целой форме (2), так и в виде десятичной дроби (1.5). Стоит рассматривать любое число как дробное (double), т.е. выражение 3/2 должно давать в результате 1.5, а не 1.

Случайные величины будут записываться в стандартной D&D нотации: XdY (например: 1d20, 2d6, 1d3), где X и Y — целые положительные числа. XdY фактически означает "взять X Y-гранных костей, бросить их и взять сумму".

Уточним, что X и Y не могут быть дробными числами, выражениями или случайными величинами; только целыми положительными числами от 1 до 100. Также зафиксируем, что между двумя случайными величинами допустимы только сложения и вычитания.

Т.е. выражение 5 * (1d20 + 4) / 7 + 1d6 — допустимо, а 1d20 * 2d6 или 1d3 / (4 + 2d20) — нет.

# Требования   

Декомпозиция:    

Код необходимо логично разделить по классам и методам. Обратити внимание, что решения без декомпозиции не пройдут ревью. Так что смело строй архитектуру и пакуй весь проект уже знакомым csharp-packer в UserCode.cs: именно его содержимое и нужно отправить на проверку.

Эффективность:   

Код должен быть асимптотически эффективен. Не стоит заменять LINQ на foreach, а заменить экспоненциальный алгоритм на полиномиальный — стоит.

Корректность:   

Код должен корректно работать не только на тех тестах, которые есть на ulearn или в примерах.

# Задача 1. Матожидание.
Проект, где можно писать код - https://ulearn.me/course/shpora2021/3_Kal_kulyator_sluchaynykh_velichin_1fa72cc1-e0d2-491a-bebb-98fe6d824479.

В рамках данного задания необходимо уметь вычислять только один вид статистики: матожидание дискретной случайной величины. При этом вычислять нужно эффективно — мы ожидаем алгоритм сложности O(n).   
| Входная строка| ExpectedValue|
|:--------------:|:-----------:|
|2+2*2|6|  
|1d20|10.5|  
|2d6+(-1d12/5)|	5.7|   
|(1d12+2d6)/2|6.75|   
|3/2.1+100d100-4d8+1d4|	5035.92857142857|  

# Задача 2. Дисперсия.
Продолжай писать код в том же проекте, что и предыдущую подзадачу.

Теперь помимо матожидания требуется еще уметь вычислять дисперсию дискретной случайной величины. И мы всё ещё ожидаем, что сложность алгоритма будет O(n).

|Входная строка|	ExpectedValue|	Variance|
|:--------------:|:-----------:|:-----------:|
|2+2*2|	6|	0|
|1d20|	10.5|	33.25|
|2d6+(-1d12/5)|	5.7|	6.31|
|(1d12+2d6)/2|	6.75|	4.4375|
|3/2.1+100d100-4d8+1d4|	5035.928571428572|	83347.25|

# Задача 3. Плотность распределения вероятности.
Продолжай писать код в том же проекте, что и предыдущую подзадачу.

Теперь помимо матожидания и дисперсии необходимо уметь рассчитывать и функцию плотности распределения дискретной случайной величины (f).

Алгоритмически задача рассчёта функции f более сложная, поэтому не будем ограничивать сложностью алгоритма при её рассчёте (однако очевидно неоптимальные решения присылать не стоит). Но помни, что ваш код всё ещё должен уметь рассчиывать матожидание и дисперсию за O(n).
|Входная строка|	f (задана словарем [ключ] = значение)|
|:--------------:|:-----------:|
|1d4|	[1] = 0.25, [2] = 0.25, [3] = 0.25, [4] = 0.25|
